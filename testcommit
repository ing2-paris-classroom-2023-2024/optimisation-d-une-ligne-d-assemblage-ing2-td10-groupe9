#include <stdlib.h>
#include <allegro.h>
#include <time.h>
#include <stdbool.h>
#define NACTEUR 10

typedef struct acteur
{
    int posx, posy;
    int depx, depy;
    int rayon;
    int couleur;
    bool visible;
} t_acteur;

t_acteur * creerActeur();
void remplirTabActeurs(t_acteur * tab[NACTEUR]);
void actualiserActeur(t_acteur *acteur);
void actualiserTabActeurs(t_acteur * tab[NACTEUR]);
void dessinerActeur(BITMAP *bmp, t_acteur *acteur);
void dessinerTabActeurs(BITMAP *bmp,t_acteur * tab[NACTEUR]);

/****************MAIN***************/

int main()
{
    // Le tableau regroupant tous les acteurs
    t_acteur * mesActeurs[NACTEUR];

    BITMAP *page;

    srand(time(NULL));

    allegro_init();
    install_keyboard();

    set_color_depth(desktop_color_depth());
    if (set_gfx_mode(GFX_AUTODETECT_WINDOWED,800,600,0,0)!=0)
    {
        allegro_message("problÃ¨me");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    page=create_bitmap(SCREEN_W,SCREEN_H);
    clear_bitmap(page);

    remplirTabActeurs(mesActeurs);


    // Boucle d'animation (pas d'interaction)
    while (!key[KEY_ESC])
    {
        clear_bitmap(page);

        actualiserTabActeurs(mesActeurs);

        dessinerTabActeurs(page,mesActeurs);

        blit(page,screen,0,0,0,0,SCREEN_W,SCREEN_H);

        rest(20);
    }

    return 0;
}
END_OF_MAIN();


t_acteur * creerActeur()
{
    t_acteur *acteur;

    int r;

    acteur = (t_acteur *)malloc(1*sizeof(t_acteur));

    r=rand()%40+1;

    acteur->posx=rand()%(SCREEN_W-2*r)+r;
    acteur->posy=rand()%(SCREEN_H-2*r)+r;

    do
    {
        acteur->depx=rand()%21-10;
        acteur->depy=rand()%21-10;
    } while (acteur->depx==0 || acteur->depy==0);

    acteur->rayon=r;

    acteur->couleur=makecol(rand()%128+128,rand()%128+128,rand()%128+128);
    acteur->visible=1;
    return acteur;
}

void remplirTabActeurs(t_acteur * tab[NACTEUR])
{
    int i;
    for (i=0;i<NACTEUR;i++)
        tab[i]=creerActeur();
}

void actualiserActeur(t_acteur *acteur)
{
    if  (  ( acteur->posx - acteur->rayon < 0 && acteur->depx < 0 ) ||
           ( acteur->posx + acteur->rayon > SCREEN_W && acteur->depx > 0) )
        acteur->depx = -acteur->depx;

    if  (  ( acteur->posy - acteur->rayon < 0 && acteur->depy < 0 ) ||
           ( acteur->posy + acteur->rayon > SCREEN_H && acteur->depy > 0) )
        acteur->depy = -acteur->depy;

    // nouvelle position = position actuelle + deplacement 
    acteur->posx = acteur->posx + acteur->depx;
    acteur->posy = acteur->posy + acteur->depy;
}

void actualiserTabActeurs(t_acteur * tab[NACTEUR])
{
    int i;

    for (i=0;i<NACTEUR;i++)
        actualiserActeur(tab[i]);
}

void dessinerActeur(BITMAP *bmp, t_acteur *acteur)
{
    circlefill(bmp,acteur->posx,acteur->posy,acteur->rayon,acteur->couleur);
}

void dessinerTabActeurs(BITMAP *bmp,t_acteur * tab[NACTEUR])
{
    int i;
    for (i=0;i<NACTEUR;i++)
        dessinerActeur(bmp,tab[i]);
}

